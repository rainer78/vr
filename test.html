<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Three.js â€¢ Floating Clickable Cards</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#0b1020}
    canvas{display:block}
  </style>
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
</head>
<body>
<script>
  // Scene
  const scene = new THREE.Scene();
  scene.background = new THREE.Color('#0b1020');

  // Camera
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
  camera.position.set(0, 1.2, 3);

  // Renderer
  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lights
  const ambient = new THREE.AmbientLight(0x556677, 0.6);
  scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(1, 2, 1);
  scene.add(dir);

  // Card factory
  function makeCard(x, label) {
    const group = new THREE.Group();
    group.position.set(x, 1.2, 0);

    const base = new THREE.Mesh(
      new THREE.PlaneGeometry(0.9, 1.2),
      new THREE.MeshStandardMaterial({color: 0x1f2937, roughness: 0.9, metalness: 0})
    );
    base.castShadow = base.receiveShadow = true;
    group.add(base);

    const face = new THREE.Mesh(
      new THREE.PlaneGeometry(0.86, 1.16),
      new THREE.MeshStandardMaterial({color: 0x111827})
    );
    face.position.z = 0.01;
    group.add(face);
    face.name = 'face';

    // Simple text canvas
    const canvas = document.createElement('canvas');
    canvas.width = 256; canvas.height = 256;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#111827';
    ctx.fillRect(0,0,256,256);
    ctx.fillStyle = '#e5e7eb';
    ctx.font = '28px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(label, 128, 100);
    ctx.fillStyle = '#9ca3af';
    ctx.font = '18px Arial';
    ctx.fillText('Click to interact', 128, 150);

    const tex = new THREE.CanvasTexture(canvas);
    const textPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(0.84, 1.12),
      new THREE.MeshBasicMaterial({map: tex, transparent: true})
    );
    textPlane.position.z = 0.02;
    group.add(textPlane);

    scene.add(group);
    return group;
  }

  const cards = [
    makeCard(-1.1, 'Card One'),
    makeCard(0,     'Card Two'),
    makeCard(1.1,  'Card Three'),
  ];

  // Raycasting
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  window.addEventListener('pointermove', (e) => {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  });

  window.addEventListener('click', () => {
    raycaster.setFromCamera(mouse, camera);
    // Intersect only the front faces and bases
    const meshes = [];
    cards.forEach(g => g.children.forEach(c => { if (c.isMesh) meshes.push(c); }));
    const hits = raycaster.intersectObjects(meshes, true);
    if (hits.length) {
      const root = hits[0].object.parent; // group
      // flash the face material
      const face = root.children.find(c => c.name === 'face');
      const old = face.material.color.clone();
      face.material.color.setHex(0x334155);
      setTimeout(() => face.material.color.copy(old), 180);
      console.log('Clicked:', root === cards[0] ? 'Card One' : root === cards[1] ? 'Card Two' : 'Card Three');
    }
  });

  // Float animation
  let t = 0;
  function animate() {
    requestAnimationFrame(animate);
    t += 0.016;
    cards.forEach((g, i) => {
      g.position.y = 1.2 + Math.sin(t * (1.5 + i*0.2)) * 0.1;
      g.rotation.y = Math.sin(t * 0.5 + i) * 0.05;
      g.scale.setScalar(1 + 0.0); // tweak if you want hover scale later
    });

    // Optional hover scale
    raycaster.setFromCamera(mouse, camera);
    const meshes = [];
    cards.forEach(g => g.children.forEach(c => { if (c.isMesh) meshes.push(c); }));
    const hit = raycaster.intersectObjects(meshes, true)[0];
    cards.forEach(g => g.scale.setScalar(1.0));
    if (hit) hit.object.parent.scale.setScalar(1.06);

    renderer.render(scene, camera);
  }
  animate();

  // Resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
